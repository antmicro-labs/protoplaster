#!/usr/bin/env python3
import yaml
import ast
import argparse
import sys
import os
import pytest
from collections import OrderedDict
from colorama import init, Fore, Style
from jinja2 import Environment, FileSystemLoader, select_autoescape
from pathlib import Path

init()

from protoplaster.docs.docs import TestDocs
from protoplaster.i2c.test import __file__ as i2c_test
from protoplaster.gpio.test import __file__ as gpio_test
from protoplaster.camera.test import __file__ as camera_test

CONFIG_DIR = "/etc/protoplaster"

tests_paths = {
    "i2c": i2c_test,
    "gpio": gpio_test,
    "camera": camera_test,
}


def warning(text):
    return Fore.YELLOW + f"[WARNING] {text}" + Style.RESET_ALL


def error(text):
    return Fore.RED + f"[ERROR] {text}" + Style.RESET_ALL


def info(text):
    return f"[INFO] {text}"


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("-t",
                        "--test-file",
                        type=str,
                        default=f"{CONFIG_DIR}/test.yaml",
                        help="Path to the test yaml description")
    parser.add_argument("-g", "--group", type=str, help="Group to execute")
    parser.add_argument("--list-groups",
                        action="store_true",
                        help="List possible groups to execute")
    parser.add_argument("-o",
                        "--output",
                        type=str,
                        help="A junit-xml style report of the tests results")
    parser.add_argument("--generate-docs",
                        action="store_true",
                        help="Generate documentation")
    return parser.parse_args()


def parse_yaml(yaml_file):
    with open(yaml_file) as file:
        content = yaml.safe_load(file)
    return content


def get_list_of_tests(tests_dict):
    return tests_dict if isinstance(tests_dict, list) else [tests_dict]


def load_module(module_path, module_name):
    if not os.path.isfile(f"{module_path}/test.py"):
        print(
            warning(f'Additional module "{module_name}" could not be loaded!'))
        return False
    file_abs_path = os.path.abspath(module_path)
    tests_paths[module_name] = f"{file_abs_path}/test.py"
    sys.path.append(file_abs_path)
    print(
        info(
            f'Additional module loaded "{module_name}" at path {file_abs_path}'
        ))
    return True


def extract_tests(yaml_file, group):
    content = parse_yaml(yaml_file)

    if group is not None and group in content:
        content = content[group]
    elif group is None:
        content = {
            mod_key: content[group_key][mod_key]
            for group_key in content for mod_key in content[group_key]
        }
    else:
        print(error(f'Group "{group}" not defined - Exiting!'))
        exit(1)

    tests = []
    for module_name in content:
        if module_name in tests_paths:
            content[module_name] = get_list_of_tests(content[module_name])
        elif os.path.exists(f"{CONFIG_DIR}/{module_name}") and load_module(
                f"{CONFIG_DIR}/{module_name}", module_name):
            content[module_name] = get_list_of_tests(content[module_name])
        elif '__path__' in content[module_name] and load_module(
                content[module_name]['__path__'], module_name):
            content[module_name] = get_list_of_tests(
                content[module_name]["tests"])
        else:
            print(
                warning(f'Unknown module found: "{module_name}" - Skipping!'))
            continue
        tests += [tests_paths[module_name] for _ in content[module_name]]
    return tests


def print_html_doc(tests_list):

    jinja2_env = Environment(
        loader=FileSystemLoader("./protoplaster/docs"),
        autoescape=select_autoescape()
    )
    template = jinja2_env.get_template("jinja2-doc.html")
    output = template.render(tests_list=tests_list)
    with open("docs.html", "w") as f:
        f.write(output)


def generate_docs(args):
    tests_list = []
    for test_path in args:
        py_file = Path(test_path)
        raw_tree = py_file.read_text()
        tree = ast.parse(raw_tree)
        classes = [ c for c in ast.walk(tree) if isinstance(c, ast.ClassDef)]
        class_docs = [ast.get_docstring(c) for c in classes]
        functions = [f for f in ast.walk(tree) if isinstance(f, ast.FunctionDef)]
        function_docs = [ast.get_docstring(f) for f in functions]
        test_doc = TestDocs(''.join(class_docs), function_docs)
        tests_list.append(test_doc)
    print_html_doc(tests_list)


def run_tests(args):
    tests = extract_tests(args.test_file, args.group)
    if tests == []:
        print(warning("No tests to run!"))
    output_file = f"--junitxml={args.output}"
    group = f"--group={args.group}"
    cmd = f'{" ".join(tests)} -s -p no:cacheprovider -p protoplaster.conf.params_conf --yaml_file={args.test_file} {group if args.group is not None else ""} {output_file if args.output is not None else ""}'
    pytest.main(cmd.strip().split(" "))
    if args.generate_docs:
        generate_docs(OrderedDict.fromkeys(tests).keys())


def list_groups(yaml_file):
    content = parse_yaml(yaml_file)
    for group in content:
        print(group)


if __name__ == "__main__":
    args = parse_args()
    if not os.path.exists(args.test_file):
        print(
            error(
                f"Test file {args.test_file} does not exist or you don't have sufficient permitions"
            ))
        exit(1)
    if args.list_groups:
        list_groups(args.test_file)
        exit(0)
    run_tests(args)
